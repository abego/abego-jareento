/*
 * MIT License
 *
 * Copyright (c) 2022 Udo Borkowski, (ub@abego.org)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package org.abego.jareento.javaanalysis.internal.input.jdeps;

import org.abego.commons.annotation.SPI;
import org.abego.jareento.base.JareentoException;
import org.abego.stringgraph.core.exception.StringGraphException;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Reads "DOT" files of the jdeps tool and generates events for parsed elements,
 * to be processed by interested listener {@link EventHandler}.
 * <p>
 * If you want to generate the "DOT" files for a project following the standard
 * Maven directory run this command after having compiled your project:
 * <pre>
 * jdeps -v -dotoutput target/jdeps-dotoutput target/classes
 * </pre>
 * This will write the dependencies of the classes in the project's code to
 * two files in "target/jdeps-dotoutput".
 * <p>
 * This is NOT a complete DOT parser, just sufficient to
 * read the DOT file generated by the jdeps tool.
 */
class JDepsDotReader {

    //region SPI (EventHandler)
    @SPI
    public interface EventHandler {
        default void onStart(String graphName, int lineNumber) {
        }

        default void onEnd(int lineNumber) {
        }

        default void onComment(String commentText, int lineNumber) {
        }

        default void onEdge(String from, String to, int lineNumber) {
        }

        default void onError(JareentoException exception,
                             @SuppressWarnings("unused") int lineNumber) throws JareentoException {
            throw exception;
        }
    }
    //endregion

    //region Factories
    private JDepsDotReader() {
    }

    public static JDepsDotReader newJDepsDotReader() {
        return new JDepsDotReader();
    }
    //endregion

    //region Reading/Parsing
    private static final Pattern FIRST_LINE_PATTERN = Pattern.compile(
            "\\s*digraph\\s+\"([^\"]+)\"\\s*\\{\\s*");
    /**
     * Group 1: from
     * Group 2: to
     * Group 3: comment text
     * Group 4: end (closing brace)
     */
    private static final Pattern EDGE_LINE_PATTERN = Pattern.compile(
            "\\s*(?:\"([^\"]+)\"\\s+->\\s+\"([^\"]+)\";\\s*)?(?://(.+))?(}\\s*)?");

    public void readStream(InputStream inputStream, EventHandler handler) {

        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {
            int lineNumber = 1;
            String text = reader.readLine();
            Matcher m = FIRST_LINE_PATTERN.matcher(text);
            if (m.matches()) {
                handler.onStart(m.group(1), lineNumber);
            } else {
                handler.onError(new JareentoException(
                        String.format("Unexpected header '%s'", text)), lineNumber); //NON-NLS
                handler.onStart("undefined", lineNumber); //NON-NLS
            }
            boolean endReached = false;
            do {
                lineNumber++;
                text = reader.readLine();
                m = EDGE_LINE_PATTERN.matcher(text);
                boolean eventFired = false;
                if (m.matches()) {
                    if (m.group(1) != null && m.group(2) != null) {
                        handler.onEdge(m.group(1), m.group(2), lineNumber);
                        eventFired = true;
                    }
                    if (m.group(3) != null) {
                        handler.onComment(m.group(3), lineNumber);
                        eventFired = true;
                    }
                    if (m.group(4) != null) {
                        endReached = true;
                        eventFired = true;
                    }
                }
                if (!eventFired) {
                    handler.onError(new JareentoException(
                            String.format("Unexpected line '%s'", text)), lineNumber); //NON-NLS
                }
            } while (!endReached);

            handler.onEnd(lineNumber);
        } catch (StringGraphException e) {
            throw e;
        } catch (Exception e) {
            throw new JareentoException("Error when reading jdeps dot output", e); //NON-NLS
        }
    }

    public void readFile(File file, EventHandler handler) {
        try (FileInputStream inputStream = new FileInputStream(file)) {
            readStream(inputStream, handler);
        } catch (Exception e) {
            throw new JareentoException(
                    String.format("Error when reading jdeps dot output from file '%s'", //NON-NLS
                            file.getAbsolutePath()), e); //NON-NLS
        }
    }
    //endregion

}
